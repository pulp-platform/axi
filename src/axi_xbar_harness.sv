// This property file was autogenerated by AutoCC on 2024-10-25
// to check the behavior of the original RTL module, whose interface is described below: 

/// axi_xbar: Fully-connected AXI4+ATOP crossbar with an arbitrary number of slave and master ports.
/// See `doc/axi_xbar.md` for the documentation, including the definition of parameters and ports.
module axi_xbar_wrap
import cf_math_pkg::idx_width;
#(
		parameter ASSERT_INPUTS = 0,
		parameter axi_pkg::xbar_cfg_t Cfg                                   = '0,
		parameter bit  ATOPs                                                = 1'b1,
		parameter bit [Cfg.NoSlvPorts-1:0][Cfg.NoMstPorts-1:0] Connectivity = '1,
		parameter type slv_aw_chan_t                                        = logic,
		parameter type mst_aw_chan_t                                        = logic,
		parameter type w_chan_t                                             = logic,
		parameter type slv_b_chan_t                                         = logic,
		parameter type mst_b_chan_t                                         = logic,
		parameter type slv_ar_chan_t                                        = logic,
		parameter type mst_ar_chan_t                                        = logic,
		parameter type slv_r_chan_t                                         = logic,
		parameter type mst_r_chan_t                                         = logic,
		parameter type slv_req_t                                            = logic,
		parameter type slv_resp_t                                           = logic,
		parameter type mst_req_t                                            = logic,
		parameter type mst_resp_t                                           = logic,
		parameter type rule_t                                               = axi_pkg::xbar_rule_64_t
) (
		/// Clock, positive edge triggered.
		input  logic                                                          clk_i,
		/// Asynchronous reset, active low.  
		input  logic                                                          rst_ni,
		/// Testmode enable, active high.
		input  logic                                                          test_i_2,
		input  logic                                                          test_i,
		/// AXI4+ATOP requests to the slave ports.  
		input  slv_req_t  [Cfg.NoSlvPorts-1:0]                                slv_ports_req_i_2,
		input  slv_req_t  [Cfg.NoSlvPorts-1:0]                                slv_ports_req_i,
		/// AXI4+ATOP responses of the slave ports.  
		output slv_resp_t [Cfg.NoSlvPorts-1:0]                                slv_ports_resp_o_2,
		output slv_resp_t [Cfg.NoSlvPorts-1:0]                                slv_ports_resp_o,
		/// AXI4+ATOP requests of the master ports.  
		output mst_req_t  [Cfg.NoMstPorts-1:0]                                mst_ports_req_o_2,
		output mst_req_t  [Cfg.NoMstPorts-1:0]                                mst_ports_req_o,
		/// AXI4+ATOP responses to the master ports.  
		input  mst_resp_t [Cfg.NoMstPorts-1:0]                                mst_ports_resp_i_2,
		input  mst_resp_t [Cfg.NoMstPorts-1:0]                                mst_ports_resp_i,
		/// Address map array input for the crossbar. This map is global for the whole module.
		/// It is used for routing the transactions to the respective master ports.
		/// Each master port can have multiple different rules.
		input  rule_t     [Cfg.NoAddrRules-1:0]                               addr_map_i_2,
		input  rule_t     [Cfg.NoAddrRules-1:0]                               addr_map_i,
		/// Enable default master port.
		input  logic      [Cfg.NoSlvPorts-1:0]                                en_default_mst_port_i_2,
		input  logic      [Cfg.NoSlvPorts-1:0]                                en_default_mst_port_i,
		`ifdef VCS
		/// Enables a default master port for each slave port. When this is enabled unmapped
		/// transactions get issued at the master port given by `default_mst_port_i`.
		/// When not used, tie to `'0`.  
		input  logic      [Cfg.NoSlvPorts-1:0][MstPortsIdxWidth-1:0]          default_mst_port_i_2,
		input  logic      [Cfg.NoSlvPorts-1:0][MstPortsIdxWidth-1:0]          default_mst_port_i
		`else
		/// Enables a default master port for each slave port. When this is enabled unmapped
		/// transactions get issued at the master port given by `default_mst_port_i`.
		/// When not used, tie to `'0`.  
		input  logic      [Cfg.NoSlvPorts-1:0][idx_width(Cfg.NoMstPorts)-1:0] default_mst_port_i_2,
		input  logic      [Cfg.NoSlvPorts-1:0][idx_width(Cfg.NoMstPorts)-1:0] default_mst_port_i
		`endif
	);

  // ==========
  // Parameters
  // ==========

  localparam axi_pkg::xbar_cfg_t Cfg = '{
    NoSlvPorts:         TbNumMasters,
    NoMstPorts:         TbNumSlaves,
    MaxMstTrans:        10,
    MaxSlvTrans:        6,
    FallThrough:        1'b0,
    LatencyMode:        axi_pkg::CUT_ALL_AX,
    PipelineStages:     TbPipeline,
    AxiIdWidthSlvPorts: TbAxiIdWidthMasters,
    AxiIdUsedSlvPorts:  TbAxiIdUsed,
    UniqueIds:          TbUniqueIds,
    AxiAddrWidth:       TbAxiAddrWidth,
    AxiDataWidth:       TbAxiDataWidth,
    NoAddrRules:        TbNumSlaves
  };
  

//==============================================================================
// Instance Modules
//==============================================================================

	axi_xbar #(
	.Cfg(Cfg),
	.ATOPs(ATOPs),
	.Connectivity(Connectivity),
	.slv_aw_chan_t(slv_aw_chan_t),
	.mst_aw_chan_t(mst_aw_chan_t),
	.w_chan_t(w_chan_t),
	.slv_b_chan_t(slv_b_chan_t),
	.mst_b_chan_t(mst_b_chan_t),
	.slv_ar_chan_t(slv_ar_chan_t),
	.mst_ar_chan_t(mst_ar_chan_t),
	.slv_r_chan_t(slv_r_chan_t),
	.mst_r_chan_t(mst_r_chan_t),
	.slv_req_t(slv_req_t),
	.slv_resp_t(slv_resp_t),
	.mst_req_t(mst_req_t),
	.mst_resp_t(mst_resp_t),
	.rule_t(rule_t)
	) u_axi_xbar (
	.clk_i(clk_i),
	.rst_ni(rst_ni),
	.test_i(test_i),
	.slv_ports_req_i(slv_ports_req_i),
	.slv_ports_resp_o(slv_ports_resp_o),
	.mst_ports_req_o(mst_ports_req_o),
	.mst_ports_resp_i(mst_ports_resp_i),
	.addr_map_i(addr_map_i),
	.en_default_mst_port_i(en_default_mst_port_i),
	.default_mst_port_i(default_mst_port_i)
);

	axi_xbar #(
	.Cfg(Cfg),
	.ATOPs(ATOPs),
	.Connectivity(Connectivity),
	.slv_aw_chan_t(slv_aw_chan_t),
	.mst_aw_chan_t(mst_aw_chan_t),
	.w_chan_t(w_chan_t),
	.slv_b_chan_t(slv_b_chan_t),
	.mst_b_chan_t(mst_b_chan_t),
	.slv_ar_chan_t(slv_ar_chan_t),
	.mst_ar_chan_t(mst_ar_chan_t),
	.slv_r_chan_t(slv_r_chan_t),
	.mst_r_chan_t(mst_r_chan_t),
	.slv_req_t(slv_req_t),
	.slv_resp_t(slv_resp_t),
	.mst_req_t(mst_req_t),
	.mst_resp_t(mst_resp_t),
	.rule_t(rule_t)
	) u_axi_xbar2 (
	.clk_i(clk_i),
	.rst_ni(rst_ni),
	.test_i(test_i_2),
	.slv_ports_req_i(slv_ports_req_i_2),
	.slv_ports_resp_o(slv_ports_resp_o_2),
	.mst_ports_req_o(mst_ports_req_o_2),
	.mst_ports_resp_i(mst_ports_resp_i_2),
	.addr_map_i(addr_map_i_2),
	.en_default_mst_port_i(en_default_mst_port_i_2),
	.default_mst_port_i(default_mst_port_i_2)
);

endmodule
